local UltraDumper = {}

local cfg = {
    log_file = "UltraDumper.log",
    also_print = true,
    max_table_depth = 5,
}

local _ORIG = {
    print = print,
    loadstring = loadstring,
    load = load,
    require = require,
    getfenv = getfenv,
    setfenv = setfenv,
    string_dump = string.dump,
    debug = debug,
}

local function safe_tostring(v)
    local ok, s = pcall(tostring, v)
    return ok and s or "<tostring-error>"
end

local function now_iso()
    local t = os.date("!*t")
    local ms = math.floor((os.clock() % 1) * 1000)
    return string.format("%04d-%02d-%02dT%02d:%02d:%02d.%03dZ",
        t.year, t.month, t.day, t.hour, t.min, t.sec, ms)
end

local function write_log(msg)
    local line = string.format("[%s] %s", now_iso(), msg)
    if cfg.also_print then _ORIG.print(line) end
    local f = io.open(cfg.log_file, "a+")
    if f then f:write(line.."\n"); f:close() end
end

local function serialize(value, seen, depth)
    seen = seen or {}
    depth = depth or 0
    local t = type(value)
    if t == "nil" or t == "boolean" or t == "number" then return tostring(value) end
    if t == "string" then return string.format("%q", value) end
    if t == "function" then return "<function "..safe_tostring(value)..">" end
    if t == "thread" then return "<thread "..safe_tostring(value)..">" end
    if t == "userdata" then return "<userdata "..safe_tostring(value)..">" end
    if t == "table" then
        if seen[value] then return "<cycle>" end
        seen[value] = true
        if depth >= cfg.max_table_depth then return "<table depth>" end
        local parts = {}
        for k,v in pairs(value) do
            parts[#parts+1] = "["..serialize(k, seen, depth+1).."]="..serialize(v, seen, depth+1)
        end
        return "{"..table.concat(parts,", ").."}"
    end
    return "<"..t..">"
end

local function snapshot_upvalues(fn)
    local ups = {}
    local i = 1
    while true do
        local name, value = _ORIG.debug.getupvalue(fn, i)
        if not name then break end
        ups[#ups+1] = {index=i,name=name,value=value,repr=serialize(value)}
        i = i + 1
    end
    return ups
end

local function dump_function(fn, label)
    label = label or "<anon>"
    local info = _ORIG.debug.getinfo(fn, "nSlu")
    write_log(("FUNCTION [%s] @ %s:%s what=%s name=%s nups=%d")
        :format(label, info.short_src or "?", info.linedefined or -1,
            info.what or "?", info.name or "?", info.nups or 0))
    for _,u in ipairs(snapshot_upvalues(fn)) do
        write_log(("  upvalue[%d] %s = %s"):format(u.index,u.name,u.repr))
    end
    if _ORIG.getfenv then
        local ok, env = pcall(_ORIG.getfenv, fn)
        if ok then write_log("  env="..serialize(env)) end
    end
    if _ORIG.string_dump then
        local ok, bc = pcall(_ORIG.string_dump, fn)
        if ok and type(bc)=="string" then
            write_log("  bytecode: <"..#bc.." bytes>")
        end
    end
end

local function wrap_callable(fn, label)
    if type(fn)~="function" then return fn end
    return function(...)
        dump_function(fn, label)
        local ok, r1,r2,r3 = pcall(fn,...)
        return (ok and r1), r2,r3
    end
end

local function wrap_loaders()
    if _ORIG.loadstring then
        _G.loadstring = function(chunk, name)
            write_log(("loadstring intercepted: %d bytes, name=%s"):format(type(chunk)=="string" and #chunk or -1, tostring(name)))
            local fn, err = _ORIG.loadstring(chunk, name)
            if fn then return wrap_callable(fn, "loadstring:"..tostring(name or "?")) end
            return fn, err
        end
    end
    if _ORIG.load then
        _G.load = function(chunk, name)
            write_log(("load intercepted: %d bytes, name=%s"):format(type(chunk)=="string" and #chunk or -1, tostring(name)))
            local fn, err = _ORIG.load(chunk, name)
            if fn then return wrap_callable(fn, "load:"..tostring(name or "?")) end
            return fn, err
        end
    end
end

function UltraDumper.install()
    wrap_loaders()
    write_log("UltraDumper INSTALLED (no hooks, executor safe)")
end

function UltraDumper.run_script(code, name)
    UltraDumper.install()
    local fn, err = loadstring(code, name or "Injected")
    if not fn then write_log("LOADSTRING ERROR: "..tostring(err)); return end
    local ok, res = pcall(fn)
    if not ok then write_log("RUNTIME ERROR: "..tostring(res)) end
end

return UltraDumper
